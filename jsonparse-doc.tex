% File: jsonparse-doc.tex
% Copyright 2024-2025 Jasper Habicht (mail(at)jasperhabicht.de).
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License version 1.3c,
% available at http://www.latex-project.org/lppl/.
%
% This file is part of the `jsonparse' package (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% This work has the LPPL maintenance status `maintained'.
%
\documentclass[a4paper]{article}
\def\jsonparsefileversion{1.2.0}
\def\jsonparsefiledate{22 February 2025}

\usepackage[T1]{fontenc}
\usepackage{Alegreya}
\usepackage{AlegreyaSans}
\usepackage{FiraMono}

\usepackage{geometry, longtable, booktabs, siunitx, tcolorbox, hyperref}
\geometry{margin=25mm, left=45mm}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[R]{\thepage}

\linespread{1.1}\selectfont
\addtolength{\skip\footins}{1em plus 5pt}
\makeatletter
\renewcommand*{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\@makefntext}[1]{%
    \noindent\hbox to 0.75em{\normalfont\@thefnmark\hss}~#1%
}
\makeatother

\tcbuselibrary{skins,listings}
\lstdefinestyle{jsonparsedocmacro}{
    basicstyle=\small\ttfamily,
    literate=*{<}{{{\color{black!50}\guilsinglleft}}}1
        {>}{{{\color{black!50}\guilsinglright}}}1,
    keywords={},
    moredelim=[is][\bfseries]{|}{|},
    moredelim=[is][\bfseries\itshape]{?}{?},
    moredelim=[is][\color{black!50}]{!}{!},
}
\lstdefinestyle{jsonparsedoccodeexample}{
    basicstyle=\small\ttfamily,
    keywords={},
}

\hypersetup{colorlinks}

\ExplSyntaxOn
\int_new:N \l_jsonparse_doc_change_int
\NewDocumentCommand{\changes}{ m m m }{
    \int_incr:N \l_jsonparse_doc_change_int
    \prop_new:c { l_jsonparse_doc_change_
        \int_to_roman:n { \l_jsonparse_doc_change_int } _prop }
    \prop_put:cnn { l_jsonparse_doc_change_
        \int_to_roman:n { \l_jsonparse_doc_change_int } _prop } { version } {#1}
    \prop_put:cnn { l_jsonparse_doc_change_
        \int_to_roman:n { \l_jsonparse_doc_change_int } _prop } { date } {#2}
    \prop_put:cnn { l_jsonparse_doc_change_
        \int_to_roman:n { \l_jsonparse_doc_change_int } _prop } { changes } {#3}
}
\NewDocumentCommand{\printchanges}{ }{
    \section{Changes}
    \begin{description}
        \setlength\itemsep{0pt}
        \int_step_inline:nn { \l_jsonparse_doc_change_int } {
            \item[
                \prop_item:cn { l_jsonparse_doc_change_
                \int_to_roman:n { ##1 } _prop } { version } ~
                \normalfont{ (
                    \prop_item:cn { l_jsonparse_doc_change_
                    \int_to_roman:n { ##1 } _prop } { date }
                ) }
            ]
            \prop_item:cn { l_jsonparse_doc_change_
            \int_to_roman:n { ##1 } _prop } { changes }
        }
    \end{description}
}

\tl_new:N \l_jsonparse_doc_doctitle_tl
\NewExpandableDocumentCommand{\makedoctitle}{ o m o m m o m }{
    \hypersetup{
        pdfauthor={#5},
        pdftitle={\IfValueTF{#1}{#1}{#2}},
        pdfsubject={\IfValueTF{#3}{#3}{#4}}
    }
    \tl_set:Nn \l_jsonparse_doc_doctitle_tl {
        \group_begin:
            \tcbset{
                title ~ style ~ hook/.style={
                    boxrule=2pt,
                    fontupper=\huge\ttfamily
                }
            }
            \setlength{\parindent}{0pt}\sffamily
            \Huge{\bfseries #2}\par\bigskip
            \Large #4\par\bigskip
            \large #5
            \IfValueT{#6}{
                \,\footnote{#6}\par\bigskip
            }
            #7\par\bigskip
            \rule{\textwidth}{.08em}
        \group_end:
    }
}

\NewExpandableDocumentCommand{\printdoctitle}{ }{
    \tl_use:N \l_jsonparse_doc_doctitle_tl
}
\ExplSyntaxOff

\tcbset{
    size=small,
    arc=2.5pt,
    outer arc=2.5pt,
    colframe=black!10,
    colback=black!10,
    title style hook/.style={},
    optional hypertarget/.code={
      \IfValueT{#1}{\pgfkeysalso{hypertarget=#1}}
    }
}

\NewTCBListing{macrodef}{ s o }{
    listing only,
    listing style={jsonparsedocmacro},
    grow to left by=2cm,
    boxrule=0pt,
    after={\par\smallskip\noindent},
    enhanced,
    optional hypertarget={#2},
    overlay={
      \IfBooleanT{#1}{
        \fill[black!50, shift={([xshift={-10pt}, yshift={-10pt-0.5em}]frame.north east)}]
          (90:3.75pt)
          \foreach \i in {1,...,4} {
            -- ({90+360/5*\i*2}:3.75pt)
          } -- cycle;
      }
    }
}

\NewTCBListing{codeexample}{ }{
    listing only,
    listing style={jsonparsedoccodeexample},
    after={\par\smallskip\noindent}
}

\NewTCBListing{codeexamplecolumns}{ }{
    text side listing,
    lefthand width=4.5cm,
    listing style={jsonparsedoccodeexample},
    after={\par\smallskip\noindent}
}

\NewTCBListing{macrodeprecated}{}{
    listing only,
    listing style={jsonparsedocmacro},
    boxrule=0pt,
    width={0.5\linewidth-2.5pt},
    box align=top,
    after=\hfill,
    colframe=black!25!red!10,
    colback=black!25!red!10
}

\NewTCBListing{macroreplacement}{}{
    listing only,
    listing style={jsonparsedocmacro},
    boxrule=0pt,
    width={0.5\linewidth-2.5pt},
    box align=top,
    before={},
    colframe=black!25!green!10,
    colback=black!25!green!10
}

\NewTotalTCBox{\macro}{ O{} v }{
    verbatim,
    size=tight,
    arc=1pt,
    outer arc=1pt,
    top=0.5pt,
    bottom=0.5pt,
    left=2pt,
    right=2pt,
    boxrule=0pt,
    colframe=black!10,
    colback=black!10,
    fontupper=\small\ttfamily,
    #1
}{\vphantom{/g}\lstinline^#2^}

\NewTotalTCBox{\titlemacro}{ s O{} m }{
    verbatim,
    size=tight,
    arc=1pt,
    outer arc=1pt,
    top=0.5pt,
    bottom=0.5pt,
    left=2pt,
    right=2pt,
    boxrule=0pt,
    colframe=black!10,
    colback=black!10,
    fontupper=\small\ttfamily,
    title style hook,
    #2
}{\vphantom{/g}\IfBooleanT{#1}{\textbackslash}#3}

\usepackage{jsonparse}

\makedoctitle
    [The jsonparse package]
    {The \titlemacro{jsonparse} package}
    {A handy way to parse, store and access JSON data from files or strings in LaTeX documents}
    {Jasper Habicht}[E-mail: \href{mailto:mail@jasperhabicht.de}{mail@jasperhabicht.de}. I am grateful to Joseph Wright, Jonathan P. Spratte and David Carlisle who helped me navigating the peculiarities of TeX and optimizing the code. Jason, the JSON parsing horse: \textcopyright{} 2024--2025 Hannah Kl√∂ber.]
    {Version \jsonparsefileversion, released on \jsonparsefiledate}

\changes{v0.3.0}{2024/04/08}{First public beta release.}
\changes{v0.5.0}{2024/04/09}{Changed from string token variables to token lists to support Unicode.}
\changes{v0.5.5}{2024/04/09}{Bug fixes, introduction and enhancement of user functions.}
\changes{v0.5.6}{2024/04/11}{Bug fixes, escaping of special chars added.}
\changes{v0.5.7}{2024/04/14}{Bug fixes, key-value option setting added.}
\changes{v0.6.0}{2024/04/15}{Bug fixes, renaming of several commands.}
\changes{v0.7.0}{2024/04/18}{Renaming and rearranging of keys, escaping of special JSON escape sequences added.}
\changes{v0.7.1}{2024/04/20}{Access to top-level keys of object added.}
\changes{v0.8.0}{2024/04/24}{Internal rewrite, escaping procedures changed.}
\changes{v0.8.2}{2024/04/26}{Bug fixes, externalizing parsed data.}
\changes{v0.8.3}{2024/04/28}{Escaping of characters with special meaning in TeX.}
\changes{v0.8.5}{2024/05/05}{Enhanced key management.}
\changes{v0.8.6}{2024/05/09}{Bug fix in nesting function.}
\changes{v0.8.7}{2024/08/08}{Corrections in documentation, error messages.}
\changes{v0.9.0}{2024/08/27}{Adaption to updated verbatim tokenization.}
\changes{v0.9.1}{2024/09/21}{Added functions to test for valid JSON numbers.}
\changes{v0.9.3}{2024/10/24}{Fixed a bug that prevented tabs in source from being parsed properly.}
\changes{v0.9.5}{2024/10/27}{Streamlining of code, clarification of explanations in documentation.}
\changes{v0.9.6}{2024/10/31}{Allowing for multiple return values when mapping over arrays.}
\changes{v0.9.7}{2024/11/05}{Streamlining of code, ensuring backward compatibility.}
\changes{v0.9.8}{2024/11/19}{Bug fixes; adding possibility to store value in token list.}
\changes{v0.9.10}{2024/12/10}{Enhanced backward compatibility; switching to linked property lists.}
\changes{v0.9.11}{2025/01/15}{Bug fixes; adding additional command to loop through arrays.}
\changes{v0.9.12}{2025/01/17}{Bug fixes; adding commands to access items in arrays.}
\changes{v1.0.0}{2025/01/20}{Streamlining of code, unification of command structure.}
\changes{v1.0.1}{2025/01/21}{Fixes in documentation. Added user command for filtering.}
\changes{v1.0.2}{2025/01/23}{Support for Unicode surrogate pairs.}
\changes{v1.0.3}{2025/01/26}{Test for valid JSON numbers expandable.}
\changes{v1.1.0}{2025/01/30}{Unified names of user functions; renaming key for keywords.}
\changes{v1.1.1}{2025/02/03}{Added option to store result of mapped inline function.}
\changes{v1.1.2}{2025/02/08}{Added option to store result of array function.}
\changes{v1.1.3}{2025/02/13}{Bug fixes.}
\changes{v1.2.0}{2025/02/22}{Unified option to store result.}

\begin{document}
\vspace*{-1cm}
\noindent\hspace*{-3.5mm}\includegraphics[width=5cm]{jason/jason.pdf}

\printdoctitle

\bigskip

\section{Introduction}

Hello guys, I am Jason, the JSON parsing horse. JSON data is my favorite thing to parse! But I found that converting JSON to TeX can be a bit tricky. Therefore, I created this package which I am happy to introduce to you.

The \macro{jsonparse} package provides a handy way to read in JSON data from files or strings in LaTeX documents, parse the data and store it in a user-defined token variable. The package allows accessing the stored data via a JavaScript-flavored syntax.

The package has been tested, but not exhaustively. The author is grateful for reporting any bugs via GitHub at \url{https://github.com/jasperhabicht/jsonparse/issues}. A site for asking questions about how to use the package and for suggestions for improvement is available at \url{https://github.com/jasperhabicht/jsonparse/discussions}.

\section{Loading the package}

To install the package, copy the package file \macro{jsonparse.sty} into the working directory or into the \macro{texmf} directory. After the package has been installed, the \macro{jsonparse} package is loaded by calling \macro{\usepackage{jsonparse}} in the preamble of the document.

The package does not load any dependencies. It can be used with PDFLaTeX, LuaLaTeX or XeLaTeX.

\begin{macrodef}
|debug|
\end{macrodef}
The package can be loaded with the option \macro{debug}. It will then output to the log file every instance of a string, a boolean (true or false) value, a null value, a number as well as the start and end of every object and the start and end of every array that is found while parsing the JSON string or JSON file.

This key can be set either as package option or using \macro{\JSONParseSet}. It can also be set locally as option to the commands \macro{\JSONParse} and \macro{\JSONParseFromFile}.

\section{General remarks of the parsing procedure}

In general, the package will read and store the JSON source and data as string, which means that all characters have category code 12 (``other''), except for spaces and (horizontal) tabs which have category code 10 (``space''). The \macro{\endlinechar} value is set to $-1$ which means that linefeeds and carriage returns are ignored by TeX. These settings are in line with the JSON specification of handling whitespace. Furthermore, if PDFLaTeX is used, the upper-half of the 8-bit range is set to ``active''. Additionally, JSON defines a small set of escape sequences and in order to be able to process these, the category code of the backslash is set to 0 (``escape'').

During parsing, the package identifies JSON objects, arrays, strings, numbers, boolean values and null values from the JSON data. It stores all these values together with the relevant keys in a property list. Once the parsing process is done, every value can be retrieved from the property list by calling the relevant key. The package ignores whitespace in the JSON data. The JSON data should be an object or an array. In general, the package accepts any valid JSON data. If a key is defined multiple times, the latter definition will silently overwrite the former.

\section{Escaping and special treatment of the input}\label{sec:escaping}

JSON strings cannot contain the two characters \macro{"} and \macro{\}. These two characters need to be escaped with a preceding backslash (\macro{\}).  This package therefore redefines locally the TeX control symbols \macro{\"}, \macro{\/}, \macro{\\}, \macro{\b}, \macro{\f}, \macro{\n}, \macro{\r}, \macro{\t} and \macro{\u}. These control symbols are prevented from expanding during parsing. For example, \macro{\"} is first defined as \macro{\exp_not:N \"} and only when typeset, \macro{\"} is expanded to \macro{"}, which ensures that strings are parsed properly.

Similarly, the control symbol \macro{\/} expands eventually to \macro{/} and \macro{\\} to \macro{\c_backslash_str} (i.\,e.\ a backslash with category code 12).

The escape sequence \macro{\u} followed by a hex value consisting of four digits eventually expands to \macro{\codepoint_generate:nn} that creates the character represented by the relevant four hex digits with category code 12 (``other''). If two escape sequences \macro{\u} with four hex digits each follow each other and together represent a Unicode surrogate pair, this surrogate pair is converted into the relevant Unicode codepoint.

The JSON escape sequences \macro{\b}, \macro{\f}, \macro{\n}, \macro{\r} and \macro{\t} eventually expand to token variables of which the contents can be set using the relevant \macro{replace} key. See more on setting options below in section \ref{sec:options}.

It is possible to insert TeX macros to the JSON source that will eventually be parsed when typesetting. Backslashes of TeX macros need to be escaped by another backslash. The TeX macros \macro{\"} and \macro{\\} must be escaped twice in the JSON source so that they become \macro{\\\"} and \macro{\\\\} respectively.

\begin{macrodef}
|\x|{<token variable name>}{<key>}
\end{macrodef}
Using the control sequence \macro{\x}, it is possible to nest JSON strings into each other. Used inside the \macro{\JSONParse} command, the control sequence takes two arguments delimited by curly braces. The first argument represents the name of the token variable that holds the parsed JSON data where the inserted JSON string should be taken from. The second argument sets the key that should be selected. The following example shows a simple use case:

\begin{codeexamplecolumns}
    \JSONParse{\myJSONdataA}{
        { "a" : { "b" : "c" } }
    }

    \JSONParse{\myJSONdataB}{
        { "d" : \x{myJSONdataA}{a} }
    }

    \JSONParseValue{\myJSONdataB}{d.b}
\end{codeexamplecolumns}

Note that the control sequence \macro{\x} is replaced by the value exactly. Therefore, if the value happens to be a string, the control sequence \macro{\x} should be placed between quotation marks (\macro{"}) in order for the resulting string to be valid JSON. The control sequence \macro{\x} is only available inside the \macro{\JSONParse} command, but not inside the \macro{\JSONParseFromFile} command.

\begin{macrodef}
|escape|={all}
|escape|={none}
|escape|={number sign}
|escape|={dollar sign}
|escape|={percent sign}
|escape|={ampersand}
|escape|={circumflex accent}
|escape|={low line}
|escape|={tilde}
\end{macrodef}
The key \macro{escape} can be used to convert characters that don't require escaping in JSON but in TeX into the relevant TeX escape sequences. Apart from the backslash and curly braces that need to be escaped anyways, these are the number sign, the dollar sign, the percent sign, the ampersand, the circumflex accent, the low line and the tilde. The characters can be selected individually separated by a comma (for example \macro{escape={dollar sign, circumflex accent, low line}}. With \macro{escape={all}}, all escaping sequences are selected, with \macro{escape={none}}, none is selected.

The naming of the relevant characters follows their Unicode names. However, \macro{hash} exists as alias for \macro{number sign}, \macro{dollar} as alias for \macro{dollar sign}, \macro{percent} for \macro{percent sign}, \macro{circumflex} for \macro{circumflex accent} and \macro{underscore} for \macro{low line}.

This key can be set using \macro{\JSONParseSet}. It can also be set locally as option to the commands \macro{\JSONParseValue}, \macro{\JSONParseArrayUse} and \macro{\JSONParseArrayMapFunction}.

\begin{macrodef}
|rescan|
|rescan|={<boolean>}
\end{macrodef}
The key \macro{rescan} can be used to activate and deactivate rescanning of the output. This key is active per default. Rescanning converts all tokens to their default category codes and TeX control sequences are expanded before typesetting. Further, during the rescanning process, JSON escape sequences are replaced and characters that don't require escaping in JSON but in TeX are replaced by the relevant TeX escape sequences.

This key can be set using \macro{\JSONParseSet}. It can also be set locally as option to the commands \macro{\JSONParseValue}, \macro{\JSONParseArrayUse} and \macro{\JSONParseArrayMapFunction}.

\section{Main user commands}

The first part of this section describes the basic commands for parsing JSON data and retrieving values from parsed JSON data. The second part of this section describes the various commands for handling arrays provided by this package.

\subsection{Basic parsing commands}

\begin{macrodef}
|\JSONParse|[<options>]{<token variable>}{<JSON string>}
\end{macrodef}
The command \macro{\JSONParse} is used to parse a JSON string and globally store the parsed result in a token variable (a property list). The second argument takes the name of the token variable that is created by the command. The third argument takes the JSON string to be parsed.

For example, using \macro{\JSONParse{\myJSONdata}{ { "key" : "value" } }}, the relevant JSON string will be parsed and the result stored in the token variable \macro{\myJSONdata} as property list. In this case, the property list only consists of one entry with the key \macro{key} and the value \macro{value}. The command \macro{\JSONParseValue{\myJSONdata}{key}}, for example, can then be used to extract the relevant value from this property list (see the description below).

The first optional argument can be used to pass options to the command that are then applied locally.

\begin{macrodef}
|\JSONParseFromFile|[<options>]{<token variable>}{<JSON file>}
\end{macrodef}
The command \macro{\JSONParseFromFile} is used to parse a JSON file and store the parsed result in a token variable (a property list). It works the same way as \macro{\JSONParse}, but instead of a JSON string, it takes as third argument the path to the JSON file relative to the working directory.

\begin{macrodef}[macro:parsevalue]
|\JSONParseValue|[<options>]{<token variable>}{<key>}
\end{macrodef}
The command \macro{\JSONParseValue} is used to select values from the token variable (property list) that has been created using the commands \macro{\JSONParse} or \macro{\JSONParseFromFile}. The second argument takes the token variable that holds the parsed JSON data. The third argument takes the key to select the relevant entry from the parsed JSON data using JavaScript syntax.

If the JSON string \macro{{ "key" : "value" }} is parsed into the token variable \macro{\myJSONdata}, using \macro{\JSONParseValue{\myJSONdata}{key}} would extract the value associated with the key \macro{key}, which in this case is \macro{value}, and typeset it to the document.

Nested objects and arrays are assigned keys that adhere to JavaScript syntax. For example, if the JSON string \macro{{ "outer_key" : { "inner_key" : "value" } }} is parsed into the token variable \macro{\myJSONdata}, to select the value associated with the key \macro{inner_key}, the command \macro{\JSONParseValue{\myJSONdata}{outer_key.inner_key}} can be used. To give an example for an array, the command \macro{\JSONParseValue{\myJSONdata}{key[0]}} selects the first value of the array associated with the key \macro{key} in the JSON string \macro{{ "key" : [ "one" , "two" ] }}.

The first optional argument can be used to pass options to the command, such as \macro{escape} or \macro{rescan}, that are then applied locally. When the option \macro{rescan} is used, the token list is rescanned before it is typeset (which means that all category codes that may have been changed before are set to the default values). This is the default behaviour. If rescanning is not desired, pass the option \macro{rescan=false} to the command.

When a key is associated with an object or array, the whole object or array is output as JSON string. The special key \macro{.} (or the string defined using the key \macro{child sep}) returns the whole JSON object (or the whole JSON array if the JSON daza only cosists of one array) as string where all characters (except for spaces and tabs) have category code 12 (``other'').

The command \macro{\JSONParseValue} is not expandable and can therefore not be used as argument of certain other arguments where expansion is needed. In such cases, the expandable command \macro{\JSONParseExpandableValue} should be used.

\begin{macrodef}
|store in|={<token variable>}
\end{macrodef}
The command \macro{\JSONParseValue} accepts the key \macro{store in} that can be used to globally store the return value globally in another token variable. If the token variable given as option to the \macro{store in} key has not yet been defined, it will be created by this command.

The token list returned by this command is a string variable where all characters have category code 12 (``other''), except for spaces and (horizontal) tabs that have category code 10 (``space'').

The key \macro{store in} can be used together with the key \macro{rescan} to rescans the return value before storing it globally in the token variable. This means that the value stored in the token list will have the category codes TeX uses per default. Option settings such as the \macro{escape} option are taken into consideration during the rescan process.

This can, for example, be necessary when numbers stored in the JSON data in scientific format should be formatted using the \macro{siunitx} package. The rescan is needed here, because otherwise the character \macro{e} would have the wrong category code and would hence not be recognised by the formatting parser as exponent marker. Let us assume the key \macro{number} in some JSON source parsed into the token variable \macro{\myJSONnumber} represents the value \macro{-1.1e-1}, then the following could be used to format the output:

\JSONParse{\myJSONnumber}{ { "number" : -1.1e-1 } }
\begin{codeexamplecolumns}
\JSONParseValue
  [rescan, store in=\mynumber]
  {\myJSONnumber}{number}
\num{\mynumber}
\end{codeexamplecolumns}

\begin{macrodef}*
|\JSONParseExpandableValue|{<token variable>}{<key>}
\end{macrodef}
Whole objects or arrays can be output as JSON string for further use in other macros using the expandable command \macro{\JSONParseExpandableValue}. The value that is returned by this command is typically a string variable where all characters have category code 12 (``other''), except for spaces and (horizontal) tabs that have category code 10 (``space''). This should be kept in mind if string comparisons should be made. A comparison against a token list with the default category codes used by TeX won't work, since letters will have category code 11 (``letter''), but it is possible to use \macro{\detokenize} to set the category codes of the token list in such a way that the comparison works.

For example, if the JSON string \macro{{ "key" : "value" }} has been parsed into the token variable \macro{\myJSONdata}, the command \macro{\JSONParseExpandableValue{\myJSONdata}{key}} will have the same meaning as \macro{\detokenize{value}} and expand to a token list with all characters having category code 12 (``other'').

\begin{macrodef}
|\JSONParseKeys|[<options>]{<token variable>}{<key>}
\end{macrodef}
The command \macro{\JSONParseKeys} is used to get all top-level keys of a JSON object as JSON array and return this array as string where all characters (except for spaces and tabs) have category code 12 (``other''). The first argument of the command takes the token variable that holds the parsed JSON data. The second argument takes the key to select the relevant entry from the parsed JSON data using JavaScript syntax.

The command \macro{\JSONParseKeys} accepts as option the key \macro{store in} to get all top-level keys of a JSON object as JSON array and parse this array into a token variable. Note that the return value is globally stored as property list, not as string. The token variable to store the keys as array is created if it does not exist.

\begin{macrodef}
|\JSONParseFilter|{<token variable>}{<token variable>}{<key>}
\end{macrodef}
The command \macro{\JSONParseFilter} is used to select a part (such as an object or an array) of a JSON object or JSON array and parse this into a token variable (a property list). The first argument denotes the token variable where the value should be stored into. The second argument of the command takes the token variable that holds the parsed JSON data. The third argument takes the key to select the relevant entry from the parsed JSON data using JavaScript syntax.

\subsection{Commands for handling arrays}

The package offers a variety of commands that can be used to process JSON arrays. Three commands are provided to loop through arrays, \macro{\JSONParseArrayUse}, \macro{\JSONParseArrayMapFunction} and \macro{\JSONParseArrayMapInline} which offer different functionality for different use cases. All three commands are implemented in a unique way and it should not be expected that what works with one of these commands also works with another. The commands differ in various respects, for example:

\begin{itemize}
  \item With \macro{\JSONParseArrayUse} and \macro{\JSONParseArrayMapInline}, it is possible to store the result in a token list for later use via the option key \macro{store in}, but such is not possible with \macro{\JSONParseArrayMapFunction}.
  \item It is possible to store non-expandable commands (such as \macro{\emph} or \macro{\textbf}) in a token list using \macro{\JSONParseArrayUse}, but not using \macro{\JSONParseArrayMapInline}.
\end{itemize}

\begin{macrodef}
|\JSONParseArrayCount|[<options>]{<token variable>}{<key>}
\end{macrodef}
The command \macro{\JSONParseArrayCount} takes as first argument a token variable holding a parsed JSON string or JSON file and as second argument a key to select an array in the JSON data. It returns an integer representing the number of items contained in the selected array.

The command \macro{\JSONParseArrayCount} accepts the use of the key \macro{store in} to globally store the number of items contained in the selected array in a token variable.

\begin{macrodef}
|\JSONParseArrayUse|[<options>]{<token variable>}{<key>}[<subkey>]{<string>}
\end{macrodef}
The command \macro{\JSONParseArrayUse} is used to select all values from an array from a parsed JSON string or JSON file. The second argument takes the token variable that holds the parsed JSON data. The first argument takes the key to select the relevant entry from the parsed JSON data using JavaScript syntax. The third argument is optional and can be used to pass a subkey, i.\,e.\ a key that is used to select a value for every item. The last argument takes a string that is inserted between all values when they are typeset.

For example, let us assume the following JSON data structure is parsed into the token variable \macro{\myJSONdata}:

\begin{codeexample}
{
  "array" : [
    {
      "key_a" : "one" ,
      "key_b" : "two"
    } ,
    {
      "key_a" : "three" ,
      "key_b" : "four"
    }
  ]
}
\end{codeexample}
\JSONParse{\myJSONdata}{ { "array" : [ { "key_a" : "one" , "key_b" : "two" } , { "key_a" : "three" , "key_b" : "four" } ] } }

When using \macro{\JSONParseArrayUse{\myJSONdata}{array}[key_a]{, }}, `\JSONParseArrayUse{\myJSONdata}{array}[key_a]{, }' is then typeset to the document.

The first optional argument can be used to pass options to the command, such as \macro{escape} or \macro{rescan}, that are then applied locally.

The command \macro{\JSONParseArrayUse} accepts as option set in the optional argument the key \macro{store in} which takes a token variable into which the result of the command should be stored globally. Storing the result of the mapped inline function can be helpful if JSON data should be reformatted for use in another function.

\begin{codeexamplecolumns}
\JSONParseArrayUse[store in=\myJSONitems]
  {\myJSONdata}{array}[key_a]{,}

\begin{tikzpicture}
  \foreach \x [count=\i] in \myJSONitems {
    \fill[blue] (\i,0) circle[radius=2pt]
      node[above=5pt, black] {\x};
  }
\end{tikzpicture}
\end{codeexamplecolumns}

\begin{macrodef}[macro:arraymapfunction]
|\JSONParseArrayMapFunction|[<options>]{<token variable>}{<key>}[<subkey>]
  {<command>}
\end{macrodef}
The command \macro{\JSONParseArrayMapFunction} works in a similar way and takes the same first three arguments as the command \macro{\JSONParseArrayUse}. However, instead of a string that is added between the array items, it takes a command (a token list) as fourth argument. This command can be defined beforehand and will be called for every array item. Inside its definition, the commands \macro{\JSONParseArrayIndex}, \macro{\JSONParseArrayKey} and \macro{\JSONParseArrayValue} can be used which are updated for each item and output the index, the key and the value of the current item respectively. Note that these commands are defined globally to make accessing them as easy as possible.

For example, let us assume the same JSON data structure as defined above parsed into the token variable \macro{\myJSONdata}. Then, the following can be done:

\begin{codeexamplecolumns}
\newcommand{\myJSONitem}{
  \item \emph{\JSONParseArrayValue}
}

\begin{itemize}
  \JSONParseArrayMapFunction{\myJSONdata}
    {array}[key_a]{\myJSONitem}
\end{itemize}
\end{codeexamplecolumns}

It is possible to make use of multiple subkeys by passing them as a comma separated list as third argument to the command. Inside the command that is called for every array item, the different keys and values can be access via commands numbered with uppercase Roman numerals such as \macro{\JSONParseArrayKeyI}, \macro{\JSONParseArrayKeyII}, \macro{\JSONParseArrayKeyIII} etc.\ and \macro{\JSONParseArrayValueI}, \macro{\JSONParseArrayValueII}, \macro{\JSONParseArrayValueIII} etc.

We can extend the above example in the following way:

\begin{codeexamplecolumns}
\newcommand{\myJSONitem}{
  \item \emph{\JSONParseArrayValueI :}
    \JSONParseArrayValueII
}

\begin{itemize}
  \JSONParseArrayMapFunction{\myJSONdata}
    {array}[key_a,key_b]{\myJSONitem}
\end{itemize}
\end{codeexamplecolumns}

\begin{macrodef}
|code before|={<code>}
|code after|={<code>}
\end{macrodef}

The \macro{\JSONParseArrayMapFunction} command also accepts the options \macro{code before} and \macro{code after}. These options can be used to place code before and after the output that is generated by the command called for every array item, for example for typesetting tabular contents.

Typesetting the above example in a tabular way can be achieved as follows:

\begin{codeexamplecolumns}
\newcommand{\myJSONitem}{
  \JSONParseArrayValueI &
  \JSONParseArrayValueII \\
}

\JSONParseArrayMapFunction[
    code before={
      \begin{tabular}{ c c }
        \textbf{key a} &
        \textbf{key b} \\ \hline
    },
    code after={
      \hline \end{tabular}
    }
  ]{\myJSONdata}
  {array}[key_a,key_b]{\myJSONitem}
\end{codeexamplecolumns}

Finally, the first optional argument of the command can be used to pass options to the command, such as \macro{escape} or \macro{rescan}, that are then applied locally.

\begin{macrodef}
|\JSONParseArrayMapInline|[<options>]{<token variable>}{<key>}{<inline function>}
\end{macrodef}
The command \macro{\JSONParseArrayMapInline} takes as first mandatory argument a token variable holding a parsed JSON string or JSON file and as second mandatory argument a key to select an array in the JSON data. The last argument can contain any code where the index of the current item is represented by \macro{#1}.

Using the above example, the mechanism could be implemented as follows:

\begin{codeexamplecolumns}
\begin{itemize}
  \JSONParseArrayMapInline{\myJSONdata}
    {array}{
    \item \JSONParseValue{\myJSONdata}
      {array[#1].key_a}
  }
\end{itemize}
\end{codeexamplecolumns}

Making use of the commands \macro{\JSONParseKeys} and \macro{\JSONParseValue} together with the \macro{store in} option, keys and values can be accessed. Due to the fact that cells create scopes, we need to repeat the part of the code that selects the current key:

\begin{codeexamplecolumns}
\JSONParseArrayMapInline{\myJSONdata}
  {array}{
  \JSONParseKeys[store in=\mykeys]
    {\myJSONdata}{array[#1]}
  \JSONParseValue
    [store in=\mykeya, rescan=false]
    {\mykeys}{[0]}
  \JSONParseValue
    [store in=\mykeyb, rescan=false]
    {\mykeys}{[1]}

  \emph{\mykeya :}
  \JSONParseValue{\myJSONdata}
    {array[#1].\mykeya}\par

  \emph{\mykeyb :}
  \JSONParseValue{\myJSONdata}
    {array[#1].\mykeyb}\par\bigskip
}
\end{codeexamplecolumns}

Note that the underscores in the names of the keys can be printed without changing to math mode in the above example by switching off rescanning via \macro{rescan=false}. This is possible because all JSON data is stored as string where all characters (except for spaces and tabs) have category code 12 (``other'').

The command \macro{\JSONParseArrayMapInline} accepts as option set in the optional argument the key \macro{store in} which takes a token variable into which the result of the mapped inline function should be stored globally. Refer to the relevant explanations to command \macro{\JSONParseArrayUse} \hyperlink{macro:arrayuse}{above} for more information. It is important to note that the inline function needs to be fully expandable. For example, it is not possible to use \macro{\JSONParseValue} in the code of the inline function while \macro{\JSONParseExpandableValue} is allowed.

Storing the result of the mapped inline function can be helpful if JSON data should be reformatted for use in a plotting functions. An example for a use case with PGFplots is shown below. In this example, the parsed JSON string \macro{{ "data": [ [0,0], [1,-1], [2,1] ] }} was stored in the token variable \macro{\myJSONplotdata}.

\JSONParse{\myJSONplotdata}{ { "data": [ [0,0], [1,-1], [2,1] ] } }
\pgfplotsset{width=5.25cm}

\begin{codeexamplecolumns}
\JSONParseArrayMapInline
  [store in={\myJSONplotcoords}]
  {\myJSONplotdata}{data}{
    (
    \JSONParseExpandableValue
      {\myJSONplotdata}{data[#1][0]}
    ,
    \JSONParseExpandableValue
      {\myJSONplotdata}{data[#1][1]}
    )
}

\begin{tikzpicture}
  \begin{axis}
    \addplot coordinates
      {\myJSONplotcoords};
  \end{axis}
\end{tikzpicture}
\end{codeexamplecolumns}

\section{Externalizing parsed JSON data}\label{sec:externalizing}

Parsing large and complex JSON files can take quite a while. In order to speed up follow-up compilation runs, this package provides a way to store parsed JSON data for future use. Once a file for externalization has been created, the package will try to load the data from this file instead of parsing the JSON data again.

\begin{macrodef}
|externalize|
|externalize|={<boolean>}
\end{macrodef}
With the key \macro{externalize} set (or set to true), a file will be created in the working directory that stores the externalization of the parsed JSON data. The file name gets the extension \macro{.jsonparse}. The file name is created automatically and consists of the name of the current file followed by an underscore and the name of the token variable where the JSON data is stored into. If a file with the same name and file extension already exists, an error will be issued.

This key can be set using \macro{\JSONParseSet}. It can also be set locally as option to the commands \macro{\JSONParse} and \macro{\JSONParseFromFile}.

\begin{macrodef}
|externalize prefix|={<string>}
\end{macrodef}
With the key \macro{externalize prefix}, a prefix can be defined that is added to the file name. Per default this is an empty string.

This key can be set using \macro{\JSONParseSet}. It can also be set locally as option to the commands \macro{\JSONParse} and \macro{\JSONParseFromFile}.

\begin{macrodef}
|externalize file name|={<token list>}
\end{macrodef}
The key \macro{externalize file name} sets the schema for the file name. The default schema is as follows:

\begin{codeexample}
\l_jsonparse_externalize_prefix_str \c_sys_jobname_str
  \c_underscore_str \l_jsonparse_current_prop_str
\end{codeexample}

The token variable \macro{\l_jsonparse_externalize_prefix_str} contains the prefix that is set using the key \macro{externalize prefix}. \macro{\c_sys_jobname_str} holds the name of the current file (the current job name), \macro{\c_underscore_str} is an underscore and the token variable \macro{\l_jsonparse_current_prop_str} contains the name of the property list where the relevant JSON data is stored into.

This key can be set using \macro{\JSONParseSet}. It can also be set locally as option to the commands \macro{\JSONParse} and \macro{\JSONParseFromFile}.

\begin{macrodef}
|\JSONParsePut|{<token variable>}{<key>}[<JSON string>]
\end{macrodef}
The command \macro{\JSONParsePut} is used by the externalization procedure to re-read already parsed JSON data to the main file. It just adds a key-value pair to the property list (where the value part is read as string). Hence, it can also be used to append more entries to an already existing property list containing parsed JSON data.

\section{Changing parsing and typesetting behavior via option keys}\label{sec:options}

The package provides a set of keys that can be set to change the separators used to select the relevant value in the JSON structure, the output that is generated from the JSON data as well as other things.

\begin{macrodef}
|\JSONParseSet|{<options>}
\end{macrodef}
The command \macro{\JSONParseSet} can be used to specify options via key-value pairs (separated by commas). Keys that are presented here as a subkey (i.\,e.\ preceded by another key and a slash such as \macro{key/subkey}) can also be set using the syntax \macro{key={subkey}} and multiple subkeys belonging to one key can be combined using commas as separator. Several user commands allow to pass keys directly which are then applied locally.

Not every key takes effect in every situation. Some keys affect the parsing procedure and thus need to be set before parsing. Some keys affect the typeset result and some keys only affect the typeset result when used in combination with specific commands.

\subsection{Keys affecting the parsing procedure}

Information about the key \macro{externalize} as well as about the related keys \macro{externalize prefix} and \macro{externalize file name} can be found above in section \ref{sec:externalizing}.

\begin{macrodef}
separator/|child|={<string>}
separator/|array left|={<string>}
separator/|array right|={<string>}
\end{macrodef}
With the key \macro{separator/child}, the separator for child objects that is used in the key to select a specific value in the JSON data structure can be changed. Per default, the child separator is a dot (\macro{.}).

With the keys \macro{separator/array left} and \macro{separator/array right}, the separators for arrays that are used in the key to select a specific value in the JSON data structure can be changed. Per default, the separators are square brackets (\macro{[} and \macro{]}). Changing these separators to curly braces (\macro{{}}) is not supported due to their grouping function in TeX.

Changing the separators can be useful if keys in the JSON structure already use these characters. These settings take place already during parsing.

These keys can be set using \macro{\JSONParseSet}. They can also be set locally as option to the commands \macro{\JSONParse} and \macro{\JSONParseFromFile}. When set using \macro{\JSONParseSet}, these keys only take effect when set before parsing.

\begin{macrodef}
|zero-based|
|zero-based|={<boolean>}
\end{macrodef}
If the key \macro{zero-based} is set (or explicitly set to \macro{true}), the index of array items starts with zero. If set to false, the indexing starts with one instead. Per default, the package uses zero-based indexing to match JavaScript notation. This setting affects indexing already during parsing.

This key can be set using \macro{\JSONParseSet}. It can also be set locally as option to the commands \macro{\JSONParse} and \macro{\JSONParseFromFile}. When set using \macro{\JSONParseSet}, this key only takes effect when set before parsing.

\begin{macrodef}
|check num|
|check num|={<boolean>}
\end{macrodef}
If set to \macro{false}, the key \macro{check num} omits an internal check of numerical expressions against the JSON specification for numbers. Turning off this feature can increase the parsing speed if many numbers are to be parsed. Checks are carried out per default.

This key can be set using \macro{\JSONParseSet}. It can also be set locally as option to the commands \macro{\JSONParse} and \macro{\JSONParseFromFile}.

\subsection{Keys affecting the typesetting}

Some keys that change the typesetting behavior are explained in other parts of this documentation.

\begin{itemize}
\item Information about the keys \macro{escape} and \macro{rescan} can be found above in section \ref{sec:escaping}.
\item Information about the key \macro{store in} can be found above in the description to the command \macro{\JSONParseValue} \hyperlink{macro:parsevalue}{above} as well as the description to the commands \macro{\JSONParseKeys}, \macro{\JSONParseArrayCount}, \macro{\JSONParseArrayUse} and \macro{\JSONParseArrayMapInline} repsectively.
\item Information about the keys \macro{code before} and \macro{code after} can be found above in the description to the command \macro{\JSONParseArrayMapFunction} \hyperlink{macro:arraymapfunction}{above}.
\end{itemize}

\begin{macrodef}
keyword/|true|={<string>}
keyword/|false|={<string>}
keyword/|null|={<string>}
\end{macrodef}
With the keys \macro{keyword/true}, \macro{keyword/false} and \macro{keyword/null}, the string that is typeset for true, false and null values can be changed. The default strings that are typeset are \macro{true}, \macro{false} and \macro{null} respectively. Only strings can be used as replacement. These replacements take place already during parsing.

These keys can be set using \macro{\JSONParseSet}. They can also be set locally as option to the commands \macro{\JSONParse} and \macro{\JSONParseFromFile}. When set using \macro{\JSONParseSet}, these keys only take effect when set before parsing.

\begin{macrodef}
replace/|backspace|={<string>}
replace/|formfeed|={<string>}
replace/|linefeed|={<string>}
replace/|carriage return|={<string>}
replace/|horizontal tab|={<string>}
\end{macrodef}
These keys can be used to set the replacement text for the JSON escape sequences \macro{\b} (backspace), \macro{\f} (formfeed), \macro{\n} (linefeed), \macro{\r} (carriage return) and \macro{\t} (horizontal tab). The default replacement string is a space in each case. Only strings can be used as replacement. These replacements take place only during typesetting.

These keys can be set using \macro{\JSONParseSet}. They can also be set locally as option to the commands \macro{\JSONParseValue}, \macro{\JSONParseArrayUse} and \macro{\JSONParseArrayMapFunction}.

\section{Deprecated commands}

The following commands displayed in red boxes on the left have been deprecated and the relevant replacement displayed in green boxes on the right should be used. To simplify the representation of the code and clarify how arguments are supposed to be used, numbers are used to identify the arguments.

\begin{macrodeprecated}
|\JSONParseSetValue|
  {<1>}{<2>}{<3>}
\end{macrodeprecated}
\hfill
\begin{macroreplacement}
|\JSONParseValue|[store in={<1>},
  rescan=false]{<2>}{<3>}
\end{macroreplacement}

\begin{macrodeprecated}
|\JSONParseSetRescanValue|
  {<1>}{<2>}{<3>}
\end{macrodeprecated}
\hfill
\begin{macroreplacement}
|\JSONParseValue|[store in={<1>},
  rescan]{<2>}{<3>}
\end{macroreplacement}

\begin{macrodeprecated}
|\JSONParseSetKeys|
  {<1>}{<2>}{<3>}
\end{macrodeprecated}
\hfill
\begin{macroreplacement}
|\JSONParseKeys|
  [store in={<1>}]{<2>}{<3>}
\end{macroreplacement}

\begin{macrodeprecated}
|\JSONParseSetArrayCount|
  {<1>}{<2>}{<3>}
\end{macrodeprecated}
\hfill
\begin{macroreplacement}
|\JSONParseArrayCount|
  [store in={<1>}]{<2>}{<3>}
\end{macroreplacement}

\begin{macrodeprecated}
|\JSONParseArrayValues|
  [<1>]{<2>}{<3>}[<4>]{<5>}
\end{macrodeprecated}
\hfill
\begin{macroreplacement}
|\JSONParseArrayUse|
  [<1>]{<2>}{<3>}[<4>]{<5>}
\end{macroreplacement}

\begin{macrodeprecated}
|\JSONParseArrayValuesMap|
  [<1>]{<2>}{<3>}[<4>]{<5>}
  [<6>][<7>]
\end{macrodeprecated}
\hfill
\begin{macroreplacement}
|\JSONParseArrayMapFunction|
  [<1>, code before={<6>},
    code after={<7>}]
  {<2>}{<3>}[<4>]{\<5>}
\end{macroreplacement}

The command \macro{\JSONParseArrayMapFunction} takes as last argument a command denoting the relevant mapping function including the preceding backslash, while the deprecated command \macro{\JSONParseArrayValuesMap} required the name of this function without preceding backslash.

To ensure backward compatibility, the deprecated commands are still supported, but their use is not recommended. The commands \macro{\JSONParseSetValue} and \macro{\JSONParseSetArrayCount} will globally set the relevant token variable.

\section{L3 commands}

The following commands are provided for defining user functions by package authors. For the conditional functions described above, apart from the variant that provides a true and a false branch, the and variants that only provide an argument for the true or for the false branch respectively are defined as well which is indicated by the letters {\itshape\macro{TF}} printed in italics.

\begin{macrodef}
|\jsonparse_parse:n| {<JSON string>}
|\jsonparse_parse:o| {<JSON string>}
|\jsonparse_parse:e| {<JSON string>}
\end{macrodef}
The command \macro{\jsonparse_parse:n} takes as argument a JSON string and populates the token variable (property list) \macro{\g_jsonparse_entries_prop} with key-value pairs representing all elements of the JSON data structure represented by this string. This command does not escape the input in any way.

\begin{macrodef}
|\jsonparse_parse_to_prop:Nn| <token variable> {<JSON string>}
|\jsonparse_parse_to_prop:No| <token variable> {<JSON string>}
|\jsonparse_parse_to_prop:Ne| <token variable> {<JSON string>}
\end{macrodef}
The command \macro{\jsonparse_parse_to_prop:Nn} creates the token variable given as the first arguments as property list and, after having called \macro{\jsonparse_parse:n} using the second argument, globally sets this newly created property list equal to \macro{\g_jsonparse_entries_prop}. If escaping is activated, this command will pre-process the input according to the selected escaping mode before forwarding it to \macro{\jsonparse_parse:n}. See more on escaping above in section \ref{sec:escaping}.

\begin{macrodef}
|\jsonparse_parse_keys:NN| <token variable> <string variable>
\end{macrodef}
The command \macro{\jsonparse_parse_keys:NN} processes the token variable given as the first arguments as property list and selects all top-level keys which are then stored in the string variable as JSON array. The pseudo key \macro{.} (or the string defined using the key \macro{child sep}) to select the complete JSON data is ignored. If the JSON data is an array, the indices (wrapped into the separators defined by \macro{separator/array left} and \macro{separator/array right}) of the items are used as keys.

\begin{macrodef}
|\jsonparse_rescan:n| {<JSON value>}
|\jsonparse_rescan:e| {<JSON value>}
\end{macrodef}
The command \macro{\jsonparse_rescan:n} rescans the JSON value given in the argument. Rescanning converts all tokens to their default category codes and TeX control sequences are expanded. Further, during the rescanning process, JSON escape sequences are replaced and characters that don't require escaping in JSON but in TeX are replaced by the relevant TeX escape sequences.

\begin{macrodef}
|\jsonparse_set_rescan:Nn| <token variable> {<JSON value>}
|\jsonparse_set_rescan:Ne| <token variable> {<JSON value>}
\end{macrodef}
The command \macro{\jsonparse_set_rescan:Nn} rescans the JSON value given in the second argument and stores the result in the token variable specified in the second argument.

\begin{macrodef}
|\jsonparse_gset_rescan:Nn| <token variable> {<JSON value>}
|\jsonparse_gset_rescan:Ne| <token variable> {<JSON value>}
\end{macrodef}
The command \macro{\jsonparse_set_rescan:Nn} rescans the JSON value given in the second argument and stores the result globally in the token variable specified in the second argument.

\begin{macrodef}
|\jsonparse_put_right_rescan:Nn| <token variable> {<JSON value>}
|\jsonparse_put_right_rescan:Ne| <token variable> {<JSON value>}
\end{macrodef}
The command \macro{\jsonparse_put_right_rescan:Nn} rescans the JSON value given in the second argument and adds the result to the end of the token variable specified in the second argument.

\begin{macrodef}
|\jsonparse_gput_right_rescan:Nn| <token variable> {<JSON value>}
|\jsonparse_gput_right_rescan:Ne| <token variable> {<JSON value>}
\end{macrodef}
The command \macro{\jsonparse_gput_right_rescan:Nn} rescans the JSON value given in the second argument and adds the result globally to the end of the token variable specified in the second argument.

\begin{macrodef}
|\jsonparse_filter:Nn| <token variable> {<key>}
\end{macrodef}
The command \macro{\jsonparse_filter:Nn} processes the token variable given as the first arguments as property list and filters it according to the key given as second argument. Filtering means that for every entry in the property list, the key of this entry is compared against the key given to the command. If the key in the property list starts with the given key, the matching part is removed from the key in the property list. If the keys do not match, the entry is completely removed from the property list. If the second argument matches the pseudo key \macro{.} (or the string defined using the key \macro{child sep}) excactly, the complete property list except for this key is returned.

\begin{macrodef}
|\jsonparse_array_count:NN| <token variable> <integer variable>
\end{macrodef}
The command \macro{\jsonparse_array_count:NN} processes the token variable given as the first arguments as property list and, assuming that it is an array, counts its items and stores the result in the integer variable. If the token variable does not expand to a key that represents an array item, that is if the key does not start with the character defined by \macro{separator/array left}, the command will return an error. The command \macro{\JSONParseArrayCount} serves as a wrapper of this command.

\begin{macrodef}*
|\jsonparse_if_num:n|?TF? {<string>} {<true code>} {<false code>}
|\jsonparse_if_num_p:n| {<string>}
\end{macrodef}
The expandable conditional function \macro{\jsonparse_if_num:nTF} checks whether a string is a valid JSON number according the relevant specification. It executes the true code if the string is a valid JSON number and the false code if not. The variants that only provide an argument for the true or false case work accordingly. The command \macro{\jsonparse_if_num_p:n} returns a boolean true or false (i.\,e.\ \macro{\c_true_bool} or \macro{\c_false_bool}).

\begin{macrodef}*
|\jsonparse_unicode_if_high_surrogate:n|?TF? {<codepoint>}
  {<true code>} {<false code>}
|\jsonparse_unicode_if_high_surrogate:e|?TF? {<codepoint>}
  {<true code>} {<false code>}
|\jsonparse_unicode_if_high_surrogate_p:n| {<codepoint>}
|\jsonparse_unicode_if_high_surrogate_p:e| {<codepoint>}
\end{macrodef}
The expandable conditional function \macro{\jsonparse_unicode_if_high_surrogate:nTF} checks whether the codepoint entered as argument (an integer that can be hexadecimal if preceded by \macro{"}) is in the range of \macro{"D800} and \macro{"DBFF} which means that it is the first part of a surrogate pair (a high surrogate). The conditional function executes the true or false code depending on the evaluation. The variants that only provide an argument for the true or false case work accordingly. The command \macro{\jsonparse_unicode_if_high_surrogate_p:n} returns a boolean true or false (i.\,e.\ \macro{\c_true_bool} or \macro{\c_false_bool}).

\begin{macrodef}*
|\jsonparse_unicode_if_low_surrogate:n|?TF? {<codepoint>}
  {<true code>} {<false code>}
|\jsonparse_unicode_if_low_surrogate:e|?TF? {<codepoint>}
  {<true code>} {<false code>}
|\jsonparse_unicode_if_low_surrogate_p:n| {<codepoint>}
|\jsonparse_unicode_if_low_surrogate_p:e| {<codepoint>}
\end{macrodef}
The expandable conditional function \macro{\jsonparse_unicode_if_low_surrogate:nTF} checks whether the codepoint entered as argument (an integer that can be hexadecimal if preceded by \macro{"}) is in the range of \macro{"DC00} and \macro{"DFFF} which means that it is the last part of a surrogate pair (a low surrogate). The conditional function executes the true or false code depending on the evaluation. The variants that only provide an argument for the true or false case work accordingly. The command \macro{\jsonparse_unicode_if_low_surrogate_p:n} returns a boolean true or false (i.\,e.\ \macro{\c_true_bool} or \macro{\c_false_bool}).

\begin{macrodef}*
|\jsonparse_unicode_convert_surrogate_pair:nn| {<codepoint>} {<codepoint>}
|\jsonparse_unicode_convert_surrogate_pair:ee| {<codepoint>} {<codepoint>}
\end{macrodef}
The expandable command \macro{\jsonparse_unicode_convert_surrogate_pair:nn} converts a surrogate pair to the relevant Unicode codepoint. The returned value is an integer. It takes as first argument the codepoint of the low surrogate and as second argument the codepoint of the high surrogate. It does not check whether the codepoints actually belong to the relevant ranges of codepoints for high and low surrogates.

% =====

\printchanges

\end{document}

%% End of file `jsonparse-doc.tex`.
